<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Nightcore Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        
        :root {
            /* Default: Pitch Black Theme */
            --bg-main: #000000;
            --bg-secondary: #0a0a0a;
            --bg-panel: rgba(20, 20, 20, 0.9);
            --border-color: rgba(255, 255, 255, 0.15);
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --accent: #818cf8;
            --accent-glow: rgba(129, 140, 248, 0.3);
            --track-bg: rgba(255, 255, 255, 0.2);
            --hover-bg: rgba(255, 255, 255, 0.1);
            
            /* Variables for visual fixes */
            --shadow-inset: rgba(0,0,0,0.3);
            --album-grad-start: #1e293b;
            --album-grad-end: #000000;
            --album-icon: #334155;
        }

        [data-theme="light"] {
            --bg-main: #f1f5f9;
            --bg-secondary: #ffffff;
            --bg-panel: rgba(255, 255, 255, 0.95);
            --border-color: rgba(0, 0, 0, 0.1);
            --text-main: #0f172a;
            --text-muted: #64748b;
            --accent: #4f46e5;
            --accent-glow: rgba(79, 70, 229, 0.2);
            --track-bg: rgba(0, 0, 0, 0.1);
            --hover-bg: rgba(0, 0, 0, 0.05);

            --shadow-inset: rgba(0,0,0,0.03);
            --album-grad-start: #ffffff;
            --album-grad-end: #cbd5e1;
            --album-icon: #94a3b8;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            transition: background-color 0.3s, color 0.3s;
            user-select: none;
            overscroll-behavior-y: none;
            -webkit-tap-highlight-color: transparent;
            /* CRITICAL FIX for Mobile Browsers: Use dynamic viewport height */
            height: 100vh;
            height: 100dvh;
        }

        .theme-bg-main { background-color: var(--bg-main); }
        .theme-bg-secondary { background-color: var(--bg-secondary); }
        .theme-bg-panel { background: var(--bg-panel); backdrop-filter: blur(12px); border: 1px solid var(--border-color); }
        .theme-text-main { color: var(--text-main); }
        .theme-text-muted { color: var(--text-muted); }
        .theme-border { border-color: var(--border-color); }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--track-bg); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .visualizer-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 120px; 
            overflow: hidden;
            border-radius: 1rem;
            box-shadow: inset 0 0 50px var(--shadow-inset);
            transition: box-shadow 0.3s ease;
        }

        /* Larger min-height for desktop */
        @media (min-width: 768px) {
            .visualizer-container {
                min-height: 250px;
            }
        }

        .album-card-bg {
            background: linear-gradient(to bottom right, var(--album-grad-start), var(--album-grad-end));
        }
        .album-icon-color { color: var(--album-icon); }

        /* Sliders */
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            height: 24px;
            cursor: pointer;
            touch-action: none; 
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: var(--track-bg);
            border-radius: 3px;
            transition: background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid var(--accent);
            margin-top: -6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.1s, background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover, 
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.3);
            background: var(--accent);
        }

        /* Slider Fill Styles */
        #volControl, #speedControl {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--accent) 0%, var(--accent) 0%, var(--track-bg) 0%, var(--track-bg) 100%);
        }
        #volControl::-webkit-slider-runnable-track, #speedControl::-webkit-slider-runnable-track { 
            background: transparent; 
            height: 100%; 
        }
        #volControl::-webkit-slider-thumb, #speedControl::-webkit-slider-thumb { 
            margin-top: -5px; 
            background: white; 
            border: none; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.4); 
        }

        .song-item { transition: all 0.2s; }
        .song-item.active {
            background: var(--accent-glow);
            border-left: 3px solid var(--accent);
        }
        .song-item:hover:not(.active) { background: var(--hover-bg); }

        .neon-text { text-shadow: 0 0 15px var(--accent-glow); }

        .btn-active {
            color: var(--accent);
            position: relative;
        }
        .btn-active::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background-color: var(--accent);
            border-radius: 50%;
        }

        .reverb-active {
            background-color: var(--accent-glow);
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }
        
        /* FIX: Apply hover styles ONLY on devices that actually support hover (mouse) 
           This prevents the button from looking "stuck" on mobile after tapping */
        @media (hover: hover) {
            .hover-btn-effect:hover {
                border-color: var(--accent);
                color: var(--accent);
            }
        }

        /* Safe Area Padding for iPhone/Modern Android */
        .pb-safe { 
            padding-bottom: env(safe-area-inset-bottom, 20px); 
        }
    </style>
</head>
<body data-theme="dark" class="flex flex-col overflow-hidden transition-colors duration-300 fixed inset-0">

    <!-- Mobile Sidebar Overlay -->
    <div id="sidebarOverlay" onclick="toggleSidebar()" class="fixed inset-0 bg-black/80 z-40 hidden md:hidden backdrop-blur-sm transition-opacity"></div>

    <!-- Header -->
    <header class="h-14 theme-bg-panel border-b theme-border flex items-center justify-between px-4 md:px-6 z-30 flex-shrink-0">
        <div class="flex items-center gap-3">
            <!-- Mobile Menu Toggle -->
            <button onclick="toggleSidebar()" class="md:hidden text-slate-400 hover:text-white transition p-1">
                <i data-lucide="menu" class="w-6 h-6"></i>
            </button>

            <div class="w-8 h-8 rounded-full bg-gradient-to-tr from-indigo-600 to-cyan-500 flex items-center justify-center shadow-lg shadow-indigo-500/20">
                <i data-lucide="zap" class="text-white w-4 h-4"></i>
            </div>
            <h1 class="text-base md:text-lg font-bold bg-gradient-to-r from-indigo-400 to-cyan-400 bg-clip-text text-transparent tracking-tight truncate">Nightcore Studio</h1>
        </div>
        <div class="flex gap-2">
            <!-- Theme Changer -->
            <button onclick="toggleTheme()" id="themeBtn" class="flex items-center justify-center w-8 h-8 rounded-full theme-bg-secondary theme-border border text-slate-400 hover:text-indigo-400 transition shadow-sm">
                <i data-lucide="moon" class="w-4 h-4"></i>
            </button>

            <!-- Add Folder Button -->
            <button onclick="document.getElementById('folderInput').click()" class="hidden sm:flex items-center gap-2 px-4 py-1.5 theme-bg-secondary hover:bg-indigo-500/10 rounded-full text-xs font-medium transition border theme-border theme-text-muted hover:text-indigo-400 hover:border-indigo-500/50">
                <i data-lucide="folder-plus" class="w-3.5 h-3.5"></i> Add Folder
            </button>

            <!-- Add Songs Button -->
            <button onclick="document.getElementById('fileInput').click()" class="flex items-center gap-2 px-4 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded-full text-xs font-bold transition shadow-lg shadow-indigo-500/20 text-white active:scale-95">
                <i data-lucide="plus" class="w-3.5 h-3.5"></i> <span class="hidden sm:inline">Add Songs</span>
                <span class="sm:hidden">Add</span>
            </button>
            <input type="file" id="folderInput" webkitdirectory directory multiple class="hidden" onchange="handleFiles(this.files)">
            <input type="file" id="fileInput" multiple accept="audio/*" class="hidden" onchange="handleFiles(this.files)">
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden relative">
        
        <!-- Sidebar Playlist (Drawer on Mobile) -->
        <aside id="sidebar" class="fixed md:relative inset-y-0 left-0 z-50 w-[85vw] md:w-80 theme-bg-secondary border-r theme-border flex flex-col flex-shrink-0 transition-transform duration-300 transform -translate-x-full md:translate-x-0 shadow-2xl md:shadow-none h-full">
            <div class="p-4 border-b theme-border flex items-center justify-between bg-[var(--bg-secondary)]">
                <div class="relative group flex-1 mr-2">
                    <i data-lucide="search" class="absolute left-3 top-2.5 w-4 h-4 theme-text-muted group-focus-within:text-indigo-400 transition"></i>
                    <input type="text" id="searchInput" placeholder="Search..." class="w-full theme-bg-main text-sm rounded-lg pl-9 pr-4 py-2 focus:outline-none focus:ring-1 focus:ring-indigo-500 theme-text-main placeholder-slate-500 transition border theme-border focus:border-indigo-500/50">
                </div>
                <button onclick="toggleSidebar()" class="md:hidden p-2 text-slate-400 hover:text-white bg-white/5 rounded-full">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <!-- Mobile Actions in Sidebar -->
            <div class="md:hidden px-4 py-2 border-b theme-border">
                <button onclick="document.getElementById('folderInput').click()" class="w-full flex items-center justify-center gap-2 px-3 py-2 theme-bg-main hover:bg-indigo-500/10 rounded-lg text-xs font-medium transition border theme-border theme-text-muted">
                    <i data-lucide="folder-plus" class="w-3.5 h-3.5"></i> Add Folder
                </button>
            </div>

            <div id="playlist" class="flex-1 overflow-y-auto p-2 space-y-1 scroll-smooth pb-20 md:pb-2">
                <!-- Playlist items injected here -->
                <div id="emptyState" class="h-full flex flex-col items-center justify-center theme-text-muted p-6 text-center">
                    <div class="w-16 h-16 rounded-full theme-bg-main flex items-center justify-center mb-4 border theme-border">
                        <i data-lucide="music" class="w-8 h-8 opacity-20"></i>
                    </div>
                    <p class="text-sm font-medium">Your playlist is empty</p>
                    <p class="text-xs mt-1 opacity-60">Import songs to get started</p>
                </div>
            </div>
            <div class="p-3 text-xs theme-text-muted border-t theme-border flex justify-between items-center theme-bg-secondary absolute md:relative bottom-0 w-full">
                <span id="songCount">0 songs</span>
                <button onclick="clearPlaylist()" class="hover:text-red-400 transition p-2">Clear All</button>
            </div>
        </aside>

        <!-- Main Player Area -->
        <section class="flex-1 flex flex-col relative bg-gradient-to-b from-[var(--bg-secondary)] to-[var(--bg-main)] transition-colors duration-300 w-full min-w-0">
            
            <!-- Visualizer Area -->
            <!-- Use min-h-0 to allow shrinking, but maintain a small min-height via class -->
            <div class="flex-1 flex flex-col p-3 md:p-6 relative overflow-hidden min-h-0">
                <div class="flex-1 w-full visualizer-container theme-bg-panel relative">
                    <canvas id="visualizerCanvas" class="relative z-0"></canvas>
                    
                    <!-- Static Album Art Template -->
                    <div id="albumArtPlaceholder" class="absolute inset-0 flex items-center justify-center theme-bg-main z-10 hidden">
                        <div class="flex flex-col items-center justify-center scale-75 md:scale-100 transition-transform">
                            <div class="w-32 h-32 md:w-64 md:h-64 album-card-bg rounded-2xl shadow-[0_0_50px_rgba(0,0,0,0.3)] flex items-center justify-center border theme-border relative group overflow-hidden transition-colors duration-300">
                                <div class="absolute w-full h-full bg-gradient-to-br from-indigo-600/20 to-purple-600/20 blur-xl"></div>
                                <i data-lucide="music-4" class="w-16 h-16 md:w-24 md:h-24 album-icon-color relative z-10 group-hover:scale-110 transition duration-500"></i>
                            </div>
                        </div>
                    </div>

                    <!-- Toggle Visualizer Button -->
                    <button onclick="toggleVisualizer()" id="visToggleBtn" class="absolute top-3 right-3 p-2 theme-bg-secondary hover:bg-indigo-500/10 backdrop-blur-md border theme-border rounded-lg theme-text-muted hover:text-indigo-400 transition z-20 shadow-lg group" title="Toggle Visualizer">
                        <i data-lucide="activity" class="w-4 h-4 md:w-5 md:h-5"></i>
                    </button>
                    
                    <!-- Floating Info Overlay -->
                    <div class="absolute bottom-0 left-0 w-full p-4 md:p-8 bg-gradient-to-t from-black/95 via-black/70 to-transparent flex items-end justify-between pointer-events-none z-20">
                        <div class="transform translate-y-1 transition-transform duration-500 w-full" id="songInfoContainer">
                            <h2 class="text-xl md:text-3xl font-bold text-white mb-1 md:mb-2 drop-shadow-lg neon-text truncate w-full pr-4" id="nowPlayingTitle">Nightcore Studio</h2>
                            <div class="flex items-center gap-2 md:gap-3 text-sm">
                                <span class="bg-indigo-500/20 text-indigo-300 px-1.5 py-0.5 rounded text-[10px] md:text-xs font-mono border border-indigo-500/30 flex-shrink-0" id="formatBadge">WAV</span>
                                <span class="text-slate-300 font-mono truncate text-xs md:text-sm" id="nowPlayingMeta">Ready to play</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls Bar -->
            <div class="theme-bg-panel border-t theme-border shadow-[0_-10px_40px_rgba(0,0,0,0.5)] z-50 transition-colors duration-300 shrink-0 pb-safe">
                
                <!-- 1. Progress Bar -->
                <div class="w-full px-4 pt-3 md:px-8 md:pt-6 flex items-center gap-3 text-xs font-mono theme-text-muted mb-2">
                    <span id="currentTime" class="w-8 md:w-10 text-right tabular-nums">0:00</span>
                    <div class="flex-1 relative h-6 flex items-center cursor-pointer group touch-none" id="progressBarArea">
                        <div class="absolute -inset-y-2 inset-x-0"></div> 
                        <div class="w-full h-1 bg-slate-500/30 rounded-full overflow-hidden">
                            <div class="h-full bg-indigo-500 w-0 group-hover:bg-indigo-400 transition-colors" id="progressBar"></div>
                        </div>
                        <div class="absolute h-3 w-3 bg-white rounded-full shadow-[0_0_10px_rgba(129,140,248,0.8)] opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity pointer-events-none" id="progressHandle" style="left: 0%"></div>
                    </div>
                    <span id="totalTime" class="w-8 md:w-10 tabular-nums">0:00</span>
                </div>

                <!-- 2. Controls Grid -->
                <div class="px-4 pb-4 md:px-8 md:pb-6 flex flex-wrap lg:flex-nowrap items-center justify-center lg:justify-between gap-4">
                    
                    <!-- Group 1: Transport -->
                    <div class="flex items-center gap-4 order-1 w-full sm:w-auto justify-between sm:justify-start">
                         <button onclick="toggleShuffle()" id="shuffleBtn" class="theme-text-muted hover:text-indigo-400 transition p-2 rounded-full active:bg-white/10" title="Shuffle">
                            <i data-lucide="shuffle" class="w-4 h-4"></i>
                        </button>
                         
                        <div class="flex items-center gap-6">
                            <button onclick="prevSong()" class="theme-text-muted hover:text-indigo-400 transition active:scale-90 p-1"><i data-lucide="skip-back" class="w-6 h-6 md:w-7 md:h-7"></i></button>
                            <button onclick="togglePlay()" id="playBtn" class="w-12 h-12 md:w-14 md:h-14 bg-indigo-500 text-white rounded-full flex items-center justify-center shadow-[0_0_20px_rgba(99,102,241,0.3)] hover:shadow-[0_0_25px_rgba(99,102,241,0.5)] active:scale-95 transition duration-200 hover:bg-indigo-400">
                                <i data-lucide="play" class="w-5 h-5 md:w-6 md:h-6 fill-current ml-1"></i>
                            </button>
                            <button onclick="nextSong()" class="theme-text-muted hover:text-indigo-400 transition active:scale-90 p-1"><i data-lucide="skip-forward" class="w-6 h-6 md:w-7 md:h-7"></i></button>
                        </div>

                         <button onclick="toggleRepeat()" id="repeatBtn" class="theme-text-muted hover:text-indigo-400 transition p-2 rounded-full active:bg-white/10" title="Repeat">
                            <i data-lucide="repeat" class="w-4 h-4"></i>
                        </button>
                    </div>

                    <!-- Divider -->
                    <div class="hidden lg:block h-10 w-px bg-slate-700/50 order-2"></div>

                    <!-- Group 2: Speed (Order 2) -->
                    <div class="w-full sm:w-[220px] lg:w-[240px] flex flex-col justify-center gap-1 order-2 bg-[var(--bg-secondary)] lg:bg-transparent p-2 rounded-lg lg:rounded-none border border-[var(--border-color)] lg:border-none">
                        <div class="flex justify-between text-[10px] font-bold uppercase tracking-widest theme-text-muted opacity-70">
                            <span>Speed</span>
                            <span class="text-indigo-500 font-mono" id="speedLabel">1.25x</span>
                        </div>
                        <input type="range" id="speedControl" min="0.6" max="1.5" step="0.01" value="1.25" class="w-full">
                        
                        <div class="relative w-full h-3 text-[8px] theme-text-muted font-medium mt-1 select-none">
                            <span class="absolute left-0">0.6x</span>
                            <span class="absolute left-[44%] -translate-x-1/2 text-slate-500">Normal</span>
                            <span class="absolute right-0 text-indigo-400">Nightcore</span>
                        </div>
                    </div>

                    <!-- Divider -->
                    <div class="hidden lg:block h-10 w-px bg-slate-700/50 order-4"></div>

                    <!-- Group 3: Tools (Order 3) -->
                    <div class="flex items-center gap-3 w-full sm:w-auto order-3 justify-between sm:justify-end flex-grow lg:flex-grow-0">
                        
                        <!-- Reverb Toggle -->
                        <button onclick="toggleReverb()" id="reverbBtn" class="hover-btn-effect flex items-center justify-center gap-2 px-4 py-2 rounded-lg border border-slate-600 bg-[var(--bg-secondary)] lg:bg-transparent text-xs font-semibold theme-text-muted transition duration-300 h-10 min-w-[90px]">
                            <i data-lucide="waves" class="w-4 h-4"></i>
                            <span>Reverb</span>
                        </button>

                        <!-- Volume -->
                        <div class="flex items-center gap-2 group theme-bg-secondary p-2 rounded-lg border theme-border shadow-inner flex-grow sm:flex-grow-0 sm:w-[120px] h-10">
                            <button onclick="toggleMute()" class="theme-text-muted hover:text-indigo-400 transition flex-shrink-0">
                                <i data-lucide="volume-2" id="volIcon" class="w-4 h-4"></i>
                            </button>
                            <input type="range" id="volControl" min="0" max="1" step="0.01" value="0.8" class="w-full">
                        </div>

                        <!-- Download -->
                        <button onclick="downloadCurrent()" id="downloadBtn" class="flex-shrink-0 flex items-center justify-center gap-2 px-4 py-2 bg-gradient-to-r from-indigo-600 to-blue-600 hover:from-indigo-500 hover:to-blue-500 text-white rounded-lg text-sm font-semibold shadow-lg shadow-indigo-900/50 transition active:translate-y-0.5 h-10">
                            <i data-lucide="download" class="w-4 h-4"></i>
                            <span id="downloadText" class="hidden sm:inline">Export</span>
                        </button>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <script>
        // --- Lucide Icons Init ---
        lucide.createIcons();

        // --- State Management ---
        let playlist = [];
        let currentIndex = -1;
        let audioCtx = null;
        let sourceNode = null;
        let masterGain = null;
        let dryGain = null;
        let wetGain = null;
        let convolver = null;
        let analyser = null;
        let audioBuffer = null;
        let reverbBuffer = null;
        
        let isPlaying = false;
        let isVisualizerOn = true;
        let isReverbOn = false;
        let startTime = 0;
        let pausedAt = 0;
        let playbackRate = 1.25;
        let isShuffle = false;
        let repeatMode = 0;
        let currentTheme = 'dark';
        let isSidebarOpen = false;
        let errorCount = 0; 

        // --- Elements ---
        const playlistEl = document.getElementById('playlist');
        const songCountEl = document.getElementById('songCount');
        const emptyStateEl = document.getElementById('emptyState');
        const speedControl = document.getElementById('speedControl');
        const speedLabel = document.getElementById('speedLabel');
        const volControl = document.getElementById('volControl');
        const progressBarArea = document.getElementById('progressBarArea');
        const progressBar = document.getElementById('progressBar');
        const progressHandle = document.getElementById('progressHandle');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const playBtn = document.getElementById('playBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadText = document.getElementById('downloadText');
        const nowPlayingTitle = document.getElementById('nowPlayingTitle');
        const nowPlayingMeta = document.getElementById('nowPlayingMeta');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const repeatBtn = document.getElementById('repeatBtn');
        const reverbBtn = document.getElementById('reverbBtn');
        const themeBtn = document.getElementById('themeBtn');
        const canvas = document.getElementById('visualizerCanvas');
        const ctx = canvas.getContext('2d');
        const albumArtPlaceholder = document.getElementById('albumArtPlaceholder');
        const visToggleBtn = document.getElementById('visToggleBtn');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        // --- UI Logic ---
        function toggleSidebar() {
            isSidebarOpen = !isSidebarOpen;
            if (isSidebarOpen) {
                sidebar.classList.remove('-translate-x-full');
                sidebarOverlay.classList.remove('hidden');
            } else {
                sidebar.classList.add('-translate-x-full');
                sidebarOverlay.classList.add('hidden');
            }
        }

        function toggleTheme() {
            const body = document.body;
            if (currentTheme === 'dark') {
                currentTheme = 'light';
                body.setAttribute('data-theme', 'light');
                themeBtn.innerHTML = '<i data-lucide="sun" class="w-4 h-4 text-orange-500"></i>';
            } else {
                currentTheme = 'dark';
                body.setAttribute('data-theme', 'dark');
                themeBtn.innerHTML = '<i data-lucide="moon" class="w-4 h-4 text-indigo-400"></i>';
            }
            lucide.createIcons();
            updateSliderFill(volControl);
            updateSliderFill(speedControl);
        }

        function updateSliderFill(el) {
            const val = parseFloat(el.value);
            const percentage = (val - el.min) / (el.max - el.min) * 100;
            const accentColor = currentTheme === 'dark' ? '#818cf8' : '#4f46e5';
            const trackColor = currentTheme === 'dark' ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)';
            
            el.style.background = `linear-gradient(to right, ${accentColor} 0%, ${accentColor} ${percentage}%, ${trackColor} ${percentage}%, ${trackColor} 100%)`;
        }

        volControl.addEventListener('input', (e) => {
            if (masterGain) masterGain.gain.value = e.target.value;
            updateSliderFill(e.target);
            const icon = document.getElementById('volIcon');
            if(e.target.value == 0) icon.setAttribute('data-lucide', 'volume-x');
            else if(e.target.value < 0.5) icon.setAttribute('data-lucide', 'volume-1');
            else icon.setAttribute('data-lucide', 'volume-2');
            lucide.createIcons();
        });

        updateSliderFill(volControl);
        updateSliderFill(speedControl);

        // --- Audio Init ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            setupMediaKeys();
            if(!reverbBuffer) generateReverbImpulse();
        }

        function generateReverbImpulse() {
            const duration = 2.5;
            const decay = 2.0;
            const rate = audioCtx.sampleRate;
            const length = rate * duration;
            const impulse = audioCtx.createBuffer(2, length, rate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const n = i / length;
                const volume = Math.pow(1 - n, decay);
                left[i] = (Math.random() * 2 - 1) * volume;
                right[i] = (Math.random() * 2 - 1) * volume;
            }
            reverbBuffer = impulse;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                togglePlay();
            }
        });

        function setupMediaKeys() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', togglePlay);
                navigator.mediaSession.setActionHandler('pause', togglePlay);
                navigator.mediaSession.setActionHandler('previoustrack', prevSong);
                navigator.mediaSession.setActionHandler('nexttrack', () => nextSong(false));
            }
        }

        function updateMediaSessionMetadata(title) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title,
                    artist: 'Nightcore Studio',
                    album: 'Nightcore Mix',
                    artwork: [{ src: 'https://ui-avatars.com/api/?name=NC&background=4f46e5&color=fff&size=512', sizes: '512x512', type: 'image/png' }]
                });
            }
        }

        // --- File Handling ---
        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', e => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files);
        });

        function handleFiles(files) {
            const newSongs = Array.from(files).filter(f => f.type.startsWith('audio/'));
            if (newSongs.length === 0) return;
            playlist = [...playlist, ...newSongs];
            updatePlaylistUI();
            if (currentIndex === -1) loadSong(0);
        }

        function clearPlaylist() {
            if(sourceNode) try{sourceNode.stop();}catch(e){}
            playlist = [];
            currentIndex = -1;
            isPlaying = false;
            audioBuffer = null;
            updatePlaylistUI();
            updatePlayButton();
            nowPlayingTitle.textContent = "Nightcore Studio";
            nowPlayingMeta.textContent = "Ready to play";
            progressBar.style.width = '0%';
            currentTimeEl.textContent = "0:00";
            totalTimeEl.textContent = "0:00";
        }

        function updatePlaylistUI() {
            const search = document.getElementById('searchInput').value.toLowerCase();
            playlistEl.innerHTML = '';
            if (playlist.length === 0) {
                emptyStateEl.style.display = 'flex';
                songCountEl.textContent = '0 songs';
            } else {
                emptyStateEl.style.display = 'none';
            }
            playlist.forEach((file, index) => {
                if (!file.name.toLowerCase().includes(search)) return;
                const div = document.createElement('div');
                div.className = `song-item p-3 rounded-lg cursor-pointer flex items-center justify-between group ${index === currentIndex ? 'active' : 'theme-text-muted'}`;
                div.onclick = () => {
                    loadSong(index);
                    if(window.innerWidth < 768) toggleSidebar(); 
                };
                
                const name = file.name.replace(/\.[^/.]+$/, "");
                const textColorClass = index === currentIndex ? 'text-indigo-500 font-bold' : 'theme-text-main';
                const numColorClass = index === currentIndex ? 'text-indigo-500' : 'theme-text-muted';

                div.innerHTML = `
                    <div class="flex items-center gap-3 overflow-hidden w-full">
                        <div class="w-8 h-8 flex-shrink-0 rounded theme-bg-main flex items-center justify-center ${numColorClass}">
                            ${index === currentIndex && isPlaying ? '<i data-lucide="bar-chart-2" class="w-4 h-4 animate-pulse"></i>' : `<span class="text-xs font-mono">${index + 1}</span>`}
                        </div>
                        <div class="flex flex-col overflow-hidden min-w-0">
                            <span class="text-sm truncate ${textColorClass}">${name}</span>
                            <span class="text-[10px] theme-text-muted truncate">${(file.size / 1024 / 1024).toFixed(1)} MB</span>
                        </div>
                    </div>
                `;
                playlistEl.appendChild(div);
            });
            songCountEl.textContent = `${playlist.length} songs`;
            lucide.createIcons();
        }
        
        document.getElementById('searchInput').addEventListener('input', updatePlaylistUI);

        // --- Controls Logic ---
        function toggleShuffle() {
            isShuffle = !isShuffle;
            shuffleBtn.classList.toggle('btn-active', isShuffle);
            if(isShuffle) shuffleBtn.classList.add('text-indigo-500');
            else shuffleBtn.classList.remove('text-indigo-500');
        }

        function toggleRepeat() {
            repeatMode = (repeatMode + 1) % 3;
            repeatBtn.classList.remove('btn-active', 'text-indigo-500');
            repeatBtn.innerHTML = '<i data-lucide="repeat" class="w-4 h-4"></i>';
            if (repeatMode === 1) {
                repeatBtn.classList.add('btn-active', 'text-indigo-500');
            } else if (repeatMode === 2) {
                repeatBtn.classList.add('btn-active', 'text-indigo-500');
                repeatBtn.innerHTML = '<i data-lucide="repeat-1" class="w-4 h-4"></i>';
            }
            lucide.createIcons();
        }
        
        function toggleVisualizer() {
            isVisualizerOn = !isVisualizerOn;
            if (isVisualizerOn) {
                canvas.style.opacity = '1';
                albumArtPlaceholder.classList.add('hidden');
                visToggleBtn.innerHTML = '<i data-lucide="activity" class="w-4 h-4 md:w-5 md:h-5"></i>';
                visToggleBtn.classList.remove('text-indigo-500');
                if (isPlaying) drawVisualizer();
            } else {
                canvas.style.opacity = '0';
                albumArtPlaceholder.classList.remove('hidden');
                visToggleBtn.innerHTML = '<i data-lucide="image" class="w-4 h-4 md:w-5 md:h-5"></i>';
                visToggleBtn.classList.add('text-indigo-500');
            }
            lucide.createIcons();
        }

        function toggleReverb() {
            isReverbOn = !isReverbOn;
            if(isReverbOn) reverbBtn.classList.add('reverb-active');
            else reverbBtn.classList.remove('reverb-active');

            if(isPlaying && dryGain && wetGain) {
                if(isReverbOn) {
                    dryGain.gain.setTargetAtTime(0.7, audioCtx.currentTime, 0.1);
                    wetGain.gain.setTargetAtTime(0.5, audioCtx.currentTime, 0.1);
                } else {
                    dryGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 0.1);
                    wetGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                }
            }
        }

        // --- Audio Engine ---
        async function loadSong(index) {
            initAudio();
            if (index < 0 || index >= playlist.length) return;
            if (sourceNode) {
                try { sourceNode.stop(); } catch(e){}
                sourceNode.disconnect();
            }

            currentIndex = index;
            const file = playlist[index];
            const reader = new FileReader();

            nowPlayingTitle.textContent = "Loading...";
            downloadBtn.disabled = true;
            playBtn.disabled = true;

            reader.onload = async (e) => {
                const arrayBuffer = e.target.result;
                try {
                    audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                    errorCount = 0; 
                    updatePlaylistUI();
                    playAudio(0); 
                    downloadBtn.disabled = false;
                    playBtn.disabled = false;
                    
                    const name = file.name.replace(/\.[^/.]+$/, "");
                    nowPlayingTitle.textContent = name;
                    nowPlayingMeta.textContent = `Original: ${(audioBuffer.duration / 60).toFixed(2)}m • Speed: ${playbackRate}x`;
                    updateMediaSessionMetadata(name);

                } catch (err) {
                    console.error("Decode error", err);
                    handleLoadError();
                }
            };
            
            reader.onerror = () => {
                handleLoadError();
            };

            try {
                reader.readAsArrayBuffer(file);
            } catch (e) {
                handleLoadError();
            }
        }

        function handleLoadError() {
            nowPlayingTitle.textContent = "Error loading file";
            console.warn("Skipping unplayable file:", playlist[currentIndex].name);
            
            errorCount++;
            if (errorCount < playlist.length) {
                setTimeout(() => {
                    nextSong(true);
                }, 1000); 
            } else {
                nowPlayingTitle.textContent = "Playback stopped";
                nowPlayingMeta.textContent = "Too many errors";
                errorCount = 0;
            }
        }

        function playAudio(offset) {
            if (!audioBuffer) return;
            if (sourceNode) {
                try { sourceNode.stop(); } catch(e){}
                sourceNode.disconnect();
            }

            sourceNode = audioCtx.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.playbackRate.value = playbackRate;

            if(!analyser) {
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
            }
            if(!masterGain) {
                masterGain = audioCtx.createGain();
                masterGain.gain.value = volControl.value;
                masterGain.connect(audioCtx.destination);
                analyser.connect(masterGain); 
            }

            dryGain = audioCtx.createGain();
            wetGain = audioCtx.createGain();
            convolver = audioCtx.createConvolver();
            convolver.buffer = reverbBuffer;

            sourceNode.connect(dryGain);
            dryGain.connect(analyser);
            sourceNode.connect(convolver);
            convolver.connect(wetGain);
            wetGain.connect(analyser);

            if (isReverbOn) {
                dryGain.gain.value = 0.7;
                wetGain.gain.value = 0.5;
            } else {
                dryGain.gain.value = 1.0;
                wetGain.gain.value = 0.0;
            }

            startTime = audioCtx.currentTime - (offset / playbackRate);
            pausedAt = offset;

            sourceNode.start(0, offset);
            isPlaying = true;
            
            // FIX for Media Keys: Update playback state explicitly
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'playing';
            }

            updatePlayButton();
            updatePlaylistUI();
            if (isVisualizerOn) drawVisualizer();

            sourceNode.onended = () => {
                const currentBufferTime = (audioCtx.currentTime - startTime) * playbackRate;
                if (Math.abs(currentBufferTime - audioBuffer.duration) < 0.5 || currentBufferTime > audioBuffer.duration) {
                    handleSongEnd();
                }
            };
        }

        function handleSongEnd() {
            if (repeatMode === 2) {
                playAudio(0);
            } else {
                if (currentIndex < playlist.length - 1 || repeatMode === 1 || isShuffle) {
                    nextSong(true); 
                } else {
                    isPlaying = false;
                    updatePlayButton();
                    pausedAt = 0; 
                }
            }
        }

        function togglePlay() {
            if (!audioBuffer) {
                if(playlist.length > 0) loadSong(0);
                return;
            }
            if (isPlaying) {
                sourceNode.stop();
                pausedAt = (audioCtx.currentTime - startTime) * playbackRate;
                isPlaying = false;
                
                // FIX for Media Keys: Update playback state explicitly
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
            } else {
                playAudio(pausedAt);
            }
            updatePlayButton();
        }

        function prevSong() {
            const currentBufferTime = (audioCtx.currentTime - startTime) * playbackRate;
            if (currentBufferTime > 3) {
                playAudio(0);
                return;
            }
            if (currentIndex > 0) {
                loadSong(currentIndex - 1);
            } else {
                if (repeatMode === 1) loadSong(playlist.length - 1);
            }
        }

        function nextSong(auto = false) {
            if (isShuffle) {
                let nextIndex = Math.floor(Math.random() * playlist.length);
                if (playlist.length > 1 && nextIndex === currentIndex) {
                    nextIndex = (nextIndex + 1) % playlist.length;
                }
                loadSong(nextIndex);
            } else {
                if (currentIndex < playlist.length - 1) {
                    loadSong(currentIndex + 1);
                } else if (repeatMode === 1) {
                    loadSong(0);
                } else if (!auto) {
                     loadSong(0);
                }
            }
        }

        function updatePlayButton() {
            const btn = document.getElementById('playBtn');
            if(isPlaying) {
                btn.innerHTML = `<i data-lucide="pause" class="w-5 h-5 md:w-6 md:h-6 fill-current"></i>`;
            } else {
                btn.innerHTML = `<i data-lucide="play" class="w-5 h-5 md:w-6 md:h-6 fill-current ml-1"></i>`;
            }
            lucide.createIcons();
        }

        progressBarArea.addEventListener('click', (e) => {
            if (!audioBuffer) return;
            const rect = progressBarArea.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percent = Math.max(0, Math.min(1, clickX / rect.width));
            const seekToBufferTime = audioBuffer.duration * percent;
            
            if (isPlaying) {
                playAudio(seekToBufferTime);
            } else {
                pausedAt = seekToBufferTime;
                const effectiveCurrent = seekToBufferTime / playbackRate;
                progressBar.style.width = `${percent * 100}%`;
                progressHandle.style.left = `${percent * 100}%`;
                currentTimeEl.textContent = formatTime(effectiveCurrent);
            }
        });

        function updateProgress() {
            if (isPlaying && audioBuffer) {
                const elapsed = audioCtx.currentTime - startTime;
                const currentBufferTime = elapsed * playbackRate;
                const percent = Math.min(100, (currentBufferTime / audioBuffer.duration) * 100);
                progressBar.style.width = `${percent}%`;
                progressHandle.style.left = `${percent}%`;
                
                const effectiveDuration = audioBuffer.duration / playbackRate;
                const effectiveCurrent = currentBufferTime / playbackRate;
                currentTimeEl.textContent = formatTime(effectiveCurrent);
                totalTimeEl.textContent = formatTime(effectiveDuration);
            }
            requestAnimationFrame(updateProgress);
        }
        requestAnimationFrame(updateProgress);

        function formatTime(seconds) {
            if(isNaN(seconds) || seconds < 0) return "0:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        }

        speedControl.addEventListener('input', (e) => {
            const newRate = parseFloat(e.target.value);
            updateSliderFill(e.target);
            if (isPlaying && audioBuffer) {
                const currentBufferTime = (audioCtx.currentTime - startTime) * playbackRate;
                playbackRate = newRate;
                if (sourceNode) sourceNode.playbackRate.value = playbackRate;
                startTime = audioCtx.currentTime - (currentBufferTime / playbackRate);
            } else {
                playbackRate = newRate;
            }
            speedLabel.textContent = playbackRate.toFixed(2) + 'x';
            speedLabel.className = playbackRate > 1.1 ? 'text-indigo-400 font-mono font-bold' : (playbackRate < 0.9 ? 'text-blue-400 font-mono font-bold' : 'theme-text-muted font-mono');
            nowPlayingMeta.textContent = `Original: ${(audioBuffer ? (audioBuffer.duration/60).toFixed(2) : 0)}m • Speed: ${playbackRate}x`;
            if(audioBuffer) {
                 const effectiveDuration = audioBuffer.duration / playbackRate;
                 totalTimeEl.textContent = formatTime(effectiveDuration);
            }
        });

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        function drawVisualizer() {
            if (!isPlaying || !isVisualizerOn) return;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const barCount = 100; 
            const step = Math.floor(bufferLength / barCount);
            const barWidth = (canvas.width / barCount);
            
            for(let i = 0; i < barCount; i++) {
                const value = dataArray[i * step];
                const barHeight = (value / 255) * canvas.height;
                const x = i * barWidth;
                const y = canvas.height - barHeight;

                const gradient = ctx.createLinearGradient(x, canvas.height, x, y);
                if (currentTheme === 'dark') {
                    gradient.addColorStop(0, '#4f46e5'); 
                    gradient.addColorStop(0.5, '#818cf8');
                    gradient.addColorStop(1, '#22d3ee');
                } else {
                    gradient.addColorStop(0, '#4338ca'); 
                    gradient.addColorStop(0.5, '#6366f1');
                    gradient.addColorStop(1, '#06b6d4');
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(x, y, barWidth - 2, barHeight, [4, 4, 0, 0]);
                ctx.fill();
            }
            if(isPlaying && isVisualizerOn) requestAnimationFrame(drawVisualizer);
        }

        async function downloadCurrent() {
            if (!audioBuffer) return;
            const originalText = downloadText.textContent;
            downloadBtn.disabled = true;
            downloadText.textContent = "Wait";

            const newDuration = audioBuffer.duration / playbackRate;
            const tail = isReverbOn ? 3.0 : 0;
            const renderDuration = newDuration + tail;
            const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, renderDuration * audioBuffer.sampleRate, audioBuffer.sampleRate);

            const offSource = offlineCtx.createBufferSource();
            offSource.buffer = audioBuffer;
            offSource.playbackRate.value = playbackRate;

            const offDry = offlineCtx.createGain();
            const offWet = offlineCtx.createGain();
            const offConvolver = offlineCtx.createConvolver();
            offConvolver.buffer = reverbBuffer;

            offSource.connect(offDry);
            offSource.connect(offConvolver);
            offConvolver.connect(offWet);
            offDry.connect(offlineCtx.destination);
            offWet.connect(offlineCtx.destination);

            if (isReverbOn) {
                offDry.gain.value = 0.7;
                offWet.gain.value = 0.5;
            } else {
                offDry.gain.value = 1.0;
                offWet.gain.value = 0.0;
            }

            offSource.start(0);

            try {
                const renderedBuffer = await offlineCtx.startRendering();
                const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
                const url = URL.createObjectURL(wavBlob);
                
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                const originalName = playlist[currentIndex].name.replace(/\.[^/.]+$/, "");
                const type = playbackRate < 1.0 ? "Slowed" : (playbackRate > 1.1 ? "Nightcore" : "Edit");
                const reverbTag = isReverbOn ? "_Reverb" : "";
                a.download = `${originalName}_${type}${reverbTag}.wav`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                
                downloadText.textContent = "Done";
                setTimeout(() => {
                    downloadText.textContent = originalText;
                    downloadBtn.disabled = false;
                }, 2000);

            } catch (e) {
                console.error("Export failed", e);
                downloadText.textContent = "Error";
                downloadBtn.disabled = false;
            }
        }

        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
            setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan); setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4); 

            for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
            while(pos < length) {
                for(i = 0; i < numOfChan; i++) { 
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); 
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; 
                    view.setInt16(pos, sample, true); 
                    pos += 2;
                }
                offset++; 
            }
            return new Blob([buffer], {type: "audio/wav"});
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        }

        function toggleMute() {
            const vol = document.getElementById('volControl');
            if (masterGain) {
                if(masterGain.gain.value > 0) {
                    vol.dataset.prev = masterGain.gain.value;
                    masterGain.gain.value = 0;
                    vol.value = 0;
                } else {
                    masterGain.gain.value = vol.dataset.prev || 0.8;
                    vol.value = masterGain.gain.value;
                }
                updateSliderFill(vol);
                const icon = document.getElementById('volIcon');
                if(vol.value == 0) icon.setAttribute('data-lucide', 'volume-x');
                else icon.setAttribute('data-lucide', 'volume-2');
                lucide.createIcons();
            }
        }
    </script>
</body>
</html>
